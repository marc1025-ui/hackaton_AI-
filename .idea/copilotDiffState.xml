<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/monitoring_system.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitoring_system.py" />
              <option name="updatedContent" value="from hutchinson_analyzer import HutchinsonRegulatoryAnalyzer&#10;from db import db&#10;from datetime import datetime, timedelta&#10;import time&#10;import json&#10;&#10;class HutchinsonMonitoringSystem:&#10;    &quot;&quot;&quot;&#10;    Système de monitoring en temps réel pour les changements réglementaires&#10;    Surveille les modifications et met à jour automatiquement les analyses&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.analyzer = HutchinsonRegulatoryAnalyzer()&#10;        self.regulations = db[&quot;regulations&quot;]&#10;        self.risk_analysis = db[&quot;risk_analysis&quot;]&#10;        self.alerts = db[&quot;alerts&quot;]  # Nouvelle collection pour les alertes&#10;        &#10;    def monitor_regulation_changes(self, check_interval_minutes=5):&#10;        &quot;&quot;&quot;&#10;        Surveillance continue des changements réglementaires&#10;        &#10;        Args:&#10;            check_interval_minutes (int): Intervalle de vérification en minutes&#10;        &quot;&quot;&quot;&#10;        print(f&quot; Démarrage du monitoring (vérification toutes les {check_interval_minutes} minutes)&quot;)&#10;        &#10;        while True:&#10;            try:&#10;                print(f&quot;\n⏰ {datetime.now().strftime('%H:%M:%S')} - Vérification des changements...&quot;)&#10;                &#10;                # Détecter les nouvelles réglementations&#10;                new_regulations = self._detect_new_regulations()&#10;                &#10;                # Détecter les réglementations modifiées&#10;                modified_regulations = self._detect_modified_regulations()&#10;                &#10;                # Traiter les nouvelles réglementations&#10;                if new_regulations:&#10;                    self._process_new_regulations(new_regulations)&#10;                &#10;                # Traiter les réglementations modifiées&#10;                if modified_regulations:&#10;                    self._process_modified_regulations(modified_regulations)&#10;                &#10;                # Générer des alertes si nécessaire&#10;                self._generate_alerts_if_needed()&#10;                &#10;                print(&quot;✅ Vérification terminée&quot;)&#10;                &#10;                # Attendre avant la prochaine vérification&#10;                time.sleep(check_interval_minutes * 60)&#10;                &#10;            except KeyboardInterrupt:&#10;                print(&quot;\n Arrêt du monitoring demandé&quot;)&#10;                break&#10;            except Exception as e:&#10;                print(f&quot;❌ Erreur dans le monitoring: {e}&quot;)&#10;                time.sleep(30)  # Attendre 30s avant de reprendre&#10;    &#10;    def _detect_new_regulations(self):&#10;        &quot;&quot;&quot;Détecte les nouvelles réglementations ajoutées&quot;&quot;&quot;&#10;        # Récupérer les réglementations sans analyse&#10;        analyzed_ids = set([&#10;            doc[&quot;regulation_info&quot;][&quot;id_loi&quot;] &#10;            for doc in self.risk_analysis.find({}, {&quot;regulation_info.id_loi&quot;: 1})&#10;        ])&#10;        &#10;        all_reg_ids = set([&#10;            doc[&quot;id_loi&quot;] &#10;            for doc in self.regulations.find({}, {&quot;id_loi&quot;: 1})&#10;        ])&#10;        &#10;        new_ids = all_reg_ids - analyzed_ids&#10;        &#10;        if new_ids:&#10;            new_regulations = list(self.regulations.find({&quot;id_loi&quot;: {&quot;$in&quot;: list(new_ids)}}))&#10;            return new_regulations&#10;        &#10;        return []&#10;    &#10;    def _detect_modified_regulations(self):&#10;        &quot;&quot;&quot;Détecte les réglementations modifiées récemment&quot;&quot;&quot;&#10;        # Rechercher les réglementations avec updated_at récent&#10;        recent_time = datetime.now() - timedelta(minutes=10)&#10;        &#10;        modified = list(self.regulations.find({&#10;            &quot;updated_at&quot;: {&quot;$gte&quot;: recent_time}&#10;        }))&#10;        &#10;        return modified&#10;    &#10;    def _process_new_regulations(self, new_regulations):&#10;        &quot;&quot;&quot;Traite les nouvelles réglementations&quot;&quot;&quot;&#10;        print(f&quot; {len(new_regulations)} nouvelles réglementations détectées&quot;)&#10;        &#10;        for reg in new_regulations:&#10;            try:&#10;                analysis = self.analyzer.analyze_regulation_impact_on_hutchinson(reg[&quot;id_loi&quot;])&#10;                score = analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;]&#10;                niveau = analysis[&quot;hutchinson_impact&quot;][&quot;niveau_impact&quot;]&#10;                &#10;                print(f&quot;  ✅ {reg['id_loi']}: {score}/100 ({niveau})&quot;)&#10;                &#10;                # Créer une alerte si le risque est élevé&#10;                if score &gt;= 50:&#10;                    self._create_alert(&quot;NEW_HIGH_RISK&quot;, analysis)&#10;                    &#10;            except Exception as e:&#10;                print(f&quot;  ❌ Erreur pour {reg['id_loi']}: {e}&quot;)&#10;    &#10;    def _process_modified_regulations(self, modified_regulations):&#10;        &quot;&quot;&quot;Traite les réglementations modifiées&quot;&quot;&quot;&#10;        print(f&quot; {len(modified_regulations)} réglementations modifiées détectées&quot;)&#10;        &#10;        for reg in modified_regulations:&#10;            try:&#10;                # Récupérer l'ancienne analyse&#10;                old_analysis = self.risk_analysis.find_one({&#10;                    &quot;regulation_info.id_loi&quot;: reg[&quot;id_loi&quot;]&#10;                })&#10;                &#10;                # Créer la nouvelle analyse&#10;                new_analysis = self.analyzer.analyze_regulation_impact_on_hutchinson(reg[&quot;id_loi&quot;])&#10;                &#10;                old_score = old_analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;] if old_analysis else 0&#10;                new_score = new_analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;]&#10;                &#10;                score_change = new_score - old_score&#10;                &#10;                print(f&quot;   {reg['id_loi']}: {old_score} → {new_score} (Δ{score_change:+d})&quot;)&#10;                &#10;                # Créer une alerte si le changement est significatif&#10;                if abs(score_change) &gt;= 10:&#10;                    self._create_alert(&quot;SCORE_CHANGE&quot;, new_analysis, {&#10;                        &quot;old_score&quot;: old_score,&#10;                        &quot;new_score&quot;: new_score,&#10;                        &quot;change&quot;: score_change&#10;                    })&#10;                    &#10;            except Exception as e:&#10;                print(f&quot;  ❌ Erreur pour {reg['id_loi']}: {e}&quot;)&#10;    &#10;    def _create_alert(self, alert_type, analysis, extra_data=None):&#10;        &quot;&quot;&quot;Crée une alerte dans la base de données&quot;&quot;&quot;&#10;        &#10;        alert = {&#10;            &quot;type&quot;: alert_type,&#10;            &quot;regulation_id&quot;: analysis[&quot;regulation_info&quot;][&quot;id_loi&quot;],&#10;            &quot;regulation_name&quot;: analysis[&quot;regulation_info&quot;][&quot;nom_loi&quot;],&#10;            &quot;current_score&quot;: analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;],&#10;            &quot;impact_level&quot;: analysis[&quot;hutchinson_impact&quot;][&quot;niveau_impact&quot;],&#10;            &quot;created_at&quot;: datetime.now(),&#10;            &quot;status&quot;: &quot;UNREAD&quot;,&#10;            &quot;priority&quot;: self._determine_alert_priority(analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;])&#10;        }&#10;        &#10;        if extra_data:&#10;            alert.update(extra_data)&#10;        &#10;        # Ajouter des détails spécifiques selon le type d'alerte&#10;        if alert_type == &quot;NEW_HIGH_RISK&quot;:&#10;            alert[&quot;message&quot;] = f&quot;Nouvelle réglementation à haut risque détectée: {analysis['regulation_info']['nom_loi']}&quot;&#10;        elif alert_type == &quot;SCORE_CHANGE&quot;:&#10;            alert[&quot;message&quot;] = f&quot;Changement significatif de score pour {analysis['regulation_info']['nom_loi']}: {extra_data['old_score']} → {extra_data['new_score']}&quot;&#10;        &#10;        self.alerts.insert_one(alert)&#10;        print(f&quot;   ALERTE créée: {alert['message']}&quot;)&#10;    &#10;    def _determine_alert_priority(self, score):&#10;        &quot;&quot;&quot;Détermine la priorité de l'alerte basée sur le score&quot;&quot;&quot;&#10;        if score &gt;= 70:&#10;            return &quot;CRITIQUE&quot;&#10;        elif score &gt;= 50:&#10;            return &quot;HAUTE&quot;&#10;        elif score &gt;= 30:&#10;            return &quot;MOYENNE&quot;&#10;        else:&#10;            return &quot;BASSE&quot;&#10;    &#10;    def _generate_alerts_if_needed(self):&#10;        &quot;&quot;&quot;Génère des alertes basées sur des règles métier&quot;&quot;&quot;&#10;        # Exemple: Alerte si plus de 3 réglementations critiques&#10;        critical_count = self.risk_analysis.count_documents({&#10;            &quot;hutchinson_impact.niveau_impact&quot;: &quot;CRITIQUE&quot;&#10;        })&#10;        &#10;        if critical_count &gt;= 3:&#10;            # Vérifier si cette alerte n'existe pas déjà&#10;            existing_alert = self.alerts.find_one({&#10;                &quot;type&quot;: &quot;MULTIPLE_CRITICAL&quot;,&#10;                &quot;created_at&quot;: {&quot;$gte&quot;: datetime.now() - timedelta(days=1)}&#10;            })&#10;            &#10;            if not existing_alert:&#10;                alert = {&#10;                    &quot;type&quot;: &quot;MULTIPLE_CRITICAL&quot;,&#10;                    &quot;message&quot;: f&quot;Attention: {critical_count} réglementations critiques détectées&quot;,&#10;                    &quot;count&quot;: critical_count,&#10;                    &quot;created_at&quot;: datetime.now(),&#10;                    &quot;status&quot;: &quot;UNREAD&quot;,&#10;                    &quot;priority&quot;: &quot;CRITIQUE&quot;&#10;                }&#10;                self.alerts.insert_one(alert)&#10;                print(f&quot;   ALERTE SYSTÈME: {alert['message']}&quot;)&#10;    &#10;    def get_unread_alerts(self):&#10;        &quot;&quot;&quot;Récupère toutes les alertes non lues&quot;&quot;&quot;&#10;        return list(self.alerts.find({&quot;status&quot;: &quot;UNREAD&quot;}).sort(&quot;created_at&quot;, -1))&#10;    &#10;    def mark_alert_as_read(self, alert_id):&#10;        &quot;&quot;&quot;Marque une alerte comme lue&quot;&quot;&quot;&#10;        self.alerts.update_one(&#10;            {&quot;_id&quot;: alert_id},&#10;            {&quot;$set&quot;: {&quot;status&quot;: &quot;READ&quot;, &quot;read_at&quot;: datetime.now()}}&#10;        )&#10;    &#10;    def get_dashboard_data(self):&#10;        &quot;&quot;&quot;Récupère les données pour le dashboard Streamlit&quot;&quot;&quot;&#10;        &#10;        # Statistiques générales&#10;        total_regulations = self.regulations.count_documents({})&#10;        analyzed_regulations = self.risk_analysis.count_documents({})&#10;        &#10;        # Répartition par niveau de risque&#10;        risk_distribution = {}&#10;        for level in [&quot;CRITIQUE&quot;, &quot;ELEVE&quot;, &quot;MOYEN&quot;, &quot;FAIBLE&quot;]:&#10;            count = self.risk_analysis.count_documents({&#10;                &quot;hutchinson_impact.niveau_impact&quot;: level&#10;            })&#10;            risk_distribution[level] = count&#10;        &#10;        # Top 5 des réglementations les plus risquées&#10;        top_risks = list(self.risk_analysis.find({}).sort(&#10;            &quot;hutchinson_impact.score_risque&quot;, -1&#10;        ).limit(5))&#10;        &#10;        # Alertes récentes&#10;        recent_alerts = list(self.alerts.find({}).sort(&quot;created_at&quot;, -1).limit(10))&#10;        &#10;        # Secteurs les plus impactés&#10;        sector_impacts = {}&#10;        for analysis in self.risk_analysis.find({}):&#10;            for sector_impact in analysis[&quot;hutchinson_impact&quot;][&quot;secteurs_impactes&quot;]:&#10;                sector = sector_impact[&quot;secteur&quot;]&#10;                sector_impacts[sector] = sector_impacts.get(sector, 0) + 1&#10;        &#10;        return {&#10;            &quot;total_regulations&quot;: total_regulations,&#10;            &quot;analyzed_regulations&quot;: analyzed_regulations,&#10;            &quot;risk_distribution&quot;: risk_distribution,&#10;            &quot;top_risks&quot;: top_risks,&#10;            &quot;recent_alerts&quot;: recent_alerts,&#10;            &quot;sector_impacts&quot;: sector_impacts,&#10;            &quot;last_update&quot;: datetime.now()&#10;        }&#10;    &#10;    def simulate_regulation_change(self, regulation_id):&#10;        &quot;&quot;&quot;Simule un changement de réglementation pour tester les alertes&quot;&quot;&quot;&#10;        print(f&quot; Simulation d'un changement pour {regulation_id}&quot;)&#10;        &#10;        # Marquer la réglementation comme modifiée&#10;        self.regulations.update_one(&#10;            {&quot;id_loi&quot;: regulation_id},&#10;            {&quot;$set&quot;: {&quot;updated_at&quot;: datetime.now()}}&#10;        )&#10;        &#10;        print(&quot;✅ Réglementation marquée comme modifiée&quot;)&#10;        print(&quot; Le système de monitoring détectera ce changement au prochain cycle&quot;)&#10;&#10;def demo_monitoring_system():&#10;    &quot;&quot;&quot;Démonstration du système de monitoring&quot;&quot;&quot;&#10;    &#10;    print(&quot; SYSTÈME DE MONITORING HUTCHINSON&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    monitor = HutchinsonMonitoringSystem()&#10;    &#10;    # Simuler un changement pour démonstration&#10;    print(&quot; Simulation d'un changement réglementaire...&quot;)&#10;    monitor.simulate_regulation_change(&quot;32025L0001&quot;)&#10;    &#10;    # Vérification manuelle des changements&#10;    print(&quot;\n Vérification manuelle des changements...&quot;)&#10;    new_regs = monitor._detect_new_regulations()&#10;    modified_regs = monitor._detect_modified_regulations()&#10;    &#10;    print(f&quot;Nouvelles réglementations: {len(new_regs)}&quot;)&#10;    print(f&quot;Réglementations modifiées: {len(modified_regs)}&quot;)&#10;    &#10;    if modified_regs:&#10;        monitor._process_modified_regulations(modified_regs)&#10;    &#10;    # Afficher les alertes&#10;    print(&quot;\n ALERTES:&quot;)&#10;    alerts = monitor.get_unread_alerts()&#10;    if alerts:&#10;        for alert in alerts:&#10;            print(f&quot;  • [{alert['priority']}] {alert['message']}&quot;)&#10;    else:&#10;        print(&quot;  ✅ Aucune alerte&quot;)&#10;    &#10;    # Données du dashboard&#10;    print(&quot;\n DONNÉES DASHBOARD:&quot;)&#10;    dashboard_data = monitor.get_dashboard_data()&#10;    print(f&quot;  Total réglementations: {dashboard_data['total_regulations']}&quot;)&#10;    print(f&quot;  Analysées: {dashboard_data['analyzed_regulations']}&quot;)&#10;    print(f&quot;  Répartition risques: {dashboard_data['risk_distribution']}&quot;)&#10;    print(f&quot;  Secteurs impactés: {dashboard_data['sector_impacts']}&quot;)&#10;    &#10;    print(&quot;\n Pour démarrer le monitoring en continu:&quot;)&#10;    print(&quot;  monitor.monitor_regulation_changes(check_interval_minutes=5)&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    demo_monitoring_system()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="pymongo==4.6.0&#10;python-dotenv==1.0.0&#10;sentence-transformers&#10;transformers&#10;torch&#10;requests&#10;" />
              <option name="updatedContent" value="pymongo==4.6.0&#10;python-dotenv==1.0.0&#10;sentence-transformers&#10;transformers&#10;torch&#10;requests&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/streamlit_app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/streamlit_app.py" />
              <option name="updatedContent" value="import streamlit as st&#10;import pandas as pd&#10;import plotly.express as px&#10;import plotly.graph_objects as go&#10;from datetime import datetime, timedelta&#10;from monitoring_system import HutchinsonMonitoringSystem&#10;from hutchinson_analyzer import HutchinsonRegulatoryAnalyzer&#10;import json&#10;&#10;# Configuration de la page&#10;st.set_page_config(&#10;    page_title=&quot;Hutchinson - Surveillance Réglementaire&quot;,&#10;    page_icon=&quot;&quot;,&#10;    layout=&quot;wide&quot;,&#10;    initial_sidebar_state=&quot;expanded&quot;&#10;)&#10;&#10;# Cache des données pour éviter de recharger à chaque fois&#10;@st.cache_data(ttl=300)  # Cache pendant 5 minutes&#10;def load_dashboard_data():&#10;    &quot;&quot;&quot;Charge les données du dashboard&quot;&quot;&quot;&#10;    monitor = HutchinsonMonitoringSystem()&#10;    return monitor.get_dashboard_data()&#10;&#10;@st.cache_resource&#10;def get_analyzer():&#10;    &quot;&quot;&quot;Récupère l'analyseur (en cache)&quot;&quot;&quot;&#10;    return HutchinsonRegulatoryAnalyzer()&#10;&#10;def main():&#10;    # Header&#10;    st.title(&quot; Hutchinson - Surveillance Réglementaire AI&quot;)&#10;    st.markdown(&quot;**Système d'anticipation des risques réglementaires avec IA**&quot;)&#10;    &#10;    # Sidebar&#10;    st.sidebar.title(&quot; Navigation&quot;)&#10;    page = st.sidebar.selectbox(&#10;        &quot;Choisir une page&quot;,&#10;        [&quot; Dashboard&quot;, &quot; Analyse Détaillée&quot;, &quot; Alertes&quot;, &quot;⚙️ Monitoring&quot;]&#10;    )&#10;    &#10;    # Charger les données&#10;    try:&#10;        dashboard_data = load_dashboard_data()&#10;        analyzer = get_analyzer()&#10;    except Exception as e:&#10;        st.error(f&quot;Erreur de connexion à la base de données: {e}&quot;)&#10;        st.stop()&#10;    &#10;    # Navigation des pages&#10;    if page == &quot; Dashboard&quot;:&#10;        show_dashboard(dashboard_data)&#10;    elif page == &quot; Analyse Détaillée&quot;:&#10;        show_detailed_analysis(analyzer, dashboard_data)&#10;    elif page == &quot; Alertes&quot;:&#10;        show_alerts(dashboard_data)&#10;    elif page == &quot;⚙️ Monitoring&quot;:&#10;        show_monitoring()&#10;&#10;def show_dashboard(data):&#10;    &quot;&quot;&quot;Affiche le dashboard principal&quot;&quot;&quot;&#10;    &#10;    st.header(&quot; Dashboard Principal&quot;)&#10;    &#10;    # Métriques principales&#10;    col1, col2, col3, col4 = st.columns(4)&#10;    &#10;    with col1:&#10;        st.metric(&#10;            &quot;Total Réglementations&quot;,&#10;            data[&quot;total_regulations&quot;],&#10;            delta=None&#10;        )&#10;    &#10;    with col2:&#10;        st.metric(&#10;            &quot;Analysées&quot;,&#10;            data[&quot;analyzed_regulations&quot;],&#10;            delta=f&quot;{data['analyzed_regulations'] - data['total_regulations']}&quot; if data['analyzed_regulations'] != data['total_regulations'] else None&#10;        )&#10;    &#10;    with col3:&#10;        critical_count = data[&quot;risk_distribution&quot;].get(&quot;CRITIQUE&quot;, 0)&#10;        high_count = data[&quot;risk_distribution&quot;].get(&quot;ELEVE&quot;, 0)&#10;        st.metric(&#10;            &quot;Risques Élevés/Critiques&quot;,&#10;            critical_count + high_count,&#10;            delta=None&#10;        )&#10;    &#10;    with col4:&#10;        st.metric(&#10;            &quot;Alertes Récentes&quot;,&#10;            len([a for a in data[&quot;recent_alerts&quot;] if a.get(&quot;status&quot;) == &quot;UNREAD&quot;]),&#10;            delta=None&#10;        )&#10;    &#10;    # Graphiques&#10;    col1, col2 = st.columns(2)&#10;    &#10;    with col1:&#10;        st.subheader(&quot; Répartition des Risques&quot;)&#10;        if data[&quot;risk_distribution&quot;]:&#10;            # Graphique en camembert&#10;            risk_df = pd.DataFrame(&#10;                list(data[&quot;risk_distribution&quot;].items()),&#10;                columns=[&quot;Niveau&quot;, &quot;Nombre&quot;]&#10;            )&#10;            risk_df = risk_df[risk_df[&quot;Nombre&quot;] &gt; 0]  # Retirer les 0&#10;            &#10;            if not risk_df.empty:&#10;                colors = {&#10;                    &quot;CRITIQUE&quot;: &quot;#FF4B4B&quot;,&#10;                    &quot;ELEVE&quot;: &quot;#FF8C00&quot;, &#10;                    &quot;MOYEN&quot;: &quot;#FFD700&quot;,&#10;                    &quot;FAIBLE&quot;: &quot;#32CD32&quot;&#10;                }&#10;                &#10;                fig_pie = px.pie(&#10;                    risk_df, &#10;                    values=&quot;Nombre&quot;, &#10;                    names=&quot;Niveau&quot;,&#10;                    color=&quot;Niveau&quot;,&#10;                    color_discrete_map=colors&#10;                )&#10;                st.plotly_chart(fig_pie, use_container_width=True)&#10;            else:&#10;                st.info(&quot;Aucune donnée de risque disponible&quot;)&#10;        else:&#10;            st.info(&quot;Aucune donnée de risque disponible&quot;)&#10;    &#10;    with col2:&#10;        st.subheader(&quot; Secteurs Impactés&quot;)&#10;        if data[&quot;sector_impacts&quot;]:&#10;            sector_df = pd.DataFrame(&#10;                list(data[&quot;sector_impacts&quot;].items()),&#10;                columns=[&quot;Secteur&quot;, &quot;Nombre d'Impacts&quot;]&#10;            )&#10;            &#10;            fig_bar = px.bar(&#10;                sector_df,&#10;                x=&quot;Secteur&quot;,&#10;                y=&quot;Nombre d'Impacts&quot;,&#10;                color=&quot;Nombre d'Impacts&quot;,&#10;                color_continuous_scale=&quot;Blues&quot;&#10;            )&#10;            fig_bar.update_layout(showlegend=False)&#10;            st.plotly_chart(fig_bar, use_container_width=True)&#10;        else:&#10;            st.info(&quot;Aucun impact sectoriel détecté&quot;)&#10;    &#10;    # Top risques&#10;    st.subheader(&quot;⚠️ Top 5 - Réglementations les Plus Risquées&quot;)&#10;    &#10;    if data[&quot;top_risks&quot;]:&#10;        for i, risk in enumerate(data[&quot;top_risks&quot;], 1):&#10;            reg_info = risk[&quot;regulation_info&quot;]&#10;            impact = risk[&quot;hutchinson_impact&quot;]&#10;            &#10;            # Couleur selon le niveau&#10;            color_map = {&#10;                &quot;CRITIQUE&quot;: &quot;&quot;,&#10;                &quot;ELEVE&quot;: &quot;&quot;, &#10;                &quot;MOYEN&quot;: &quot;&quot;,&#10;                &quot;FAIBLE&quot;: &quot;&quot;&#10;            }&#10;            &#10;            color = color_map.get(impact[&quot;niveau_impact&quot;], &quot;⚪&quot;)&#10;            &#10;            with st.expander(f&quot;{i}. {color} {reg_info['nom_loi'][:80]}... - Score: {impact['score_risque']}/100&quot;):&#10;                col1, col2 = st.columns(2)&#10;                &#10;                with col1:&#10;                    st.write(f&quot;**ID:** {reg_info['id_loi']}&quot;)&#10;                    st.write(f&quot;**Type:** {reg_info['type']}&quot;)&#10;                    st.write(f&quot;**Date:** {reg_info['date_publication']}&quot;)&#10;                    st.write(f&quot;**Pays:** {', '.join(reg_info['pays_concernes'])}&quot;)&#10;                &#10;                with col2:&#10;                    st.write(f&quot;**Niveau d'Impact:** {impact['niveau_impact']}&quot;)&#10;                    st.write(f&quot;**Secteurs Impactés:** {len(impact['secteurs_impactes'])}&quot;)&#10;                    st.write(f&quot;**Sites Impactés:** {len(impact['sites_impactes'])}&quot;)&#10;                    st.write(f&quot;**Sanctions Détectées:** {len(impact['sanctions_detectees'])}&quot;)&#10;                &#10;                if reg_info.get('lien_loi'):&#10;                    st.markdown(f&quot; [Voir la réglementation complète]({reg_info['lien_loi']})&quot;)&#10;    else:&#10;        st.info(&quot;Aucune analyse de risque disponible&quot;)&#10;    &#10;    # Dernière mise à jour&#10;    st.caption(f&quot;Dernière mise à jour: {data['last_update'].strftime('%d/%m/%Y %H:%M:%S')}&quot;)&#10;&#10;def show_detailed_analysis(analyzer, data):&#10;    &quot;&quot;&quot;Affiche la page d'analyse détaillée&quot;&quot;&quot;&#10;    &#10;    st.header(&quot; Analyse Détaillée&quot;)&#10;    &#10;    # Sélection d'une réglementation&#10;    if data[&quot;top_risks&quot;]:&#10;        regulation_options = {&#10;            f&quot;{risk['regulation_info']['id_loi']} - {risk['regulation_info']['nom_loi'][:50]}...&quot;: risk['regulation_info']['id_loi']&#10;            for risk in data[&quot;top_risks&quot;]&#10;        }&#10;        &#10;        selected_reg_display = st.selectbox(&#10;            &quot;Choisir une réglementation à analyser:&quot;,&#10;            list(regulation_options.keys())&#10;        )&#10;        &#10;        selected_reg_id = regulation_options[selected_reg_display]&#10;        &#10;        # Bouton pour re-analyser&#10;        if st.button(&quot; Re-analyser cette réglementation&quot;):&#10;            with st.spinner(&quot;Analyse en cours...&quot;):&#10;                try:&#10;                    analysis = analyzer.analyze_regulation_impact_on_hutchinson(selected_reg_id)&#10;                    st.success(&quot;✅ Analyse terminée!&quot;)&#10;                    &#10;                    # Afficher le rapport formaté&#10;                    formatted_report = analyzer.format_analysis_report(analysis)&#10;                    st.text(formatted_report)&#10;                    &#10;                except Exception as e:&#10;                    st.error(f&quot;Erreur lors de l'analyse: {e}&quot;)&#10;        &#10;        # Afficher l'analyse existante&#10;        existing_analysis = None&#10;        for risk in data[&quot;top_risks&quot;]:&#10;            if risk[&quot;regulation_info&quot;][&quot;id_loi&quot;] == selected_reg_id:&#10;                existing_analysis = risk&#10;                break&#10;        &#10;        if existing_analysis:&#10;            st.subheader(&quot; Analyse Actuelle&quot;)&#10;            &#10;            reg_info = existing_analysis[&quot;regulation_info&quot;]&#10;            impact = existing_analysis[&quot;hutchinson_impact&quot;]&#10;            &#10;            # Informations générales&#10;            col1, col2 = st.columns(2)&#10;            &#10;            with col1:&#10;                st.write(&quot;** Informations Réglementation:**&quot;)&#10;                st.write(f&quot;- **ID:** {reg_info['id_loi']}&quot;)&#10;                st.write(f&quot;- **Type:** {reg_info['type']}&quot;)&#10;                st.write(f&quot;- **Date publication:** {reg_info['date_publication']}&quot;)&#10;                st.write(f&quot;- **Pays concernés:** {', '.join(reg_info['pays_concernes'])}&quot;)&#10;                &#10;                if reg_info.get('lien_loi'):&#10;                    st.markdown(f&quot; [Lien officiel]({reg_info['lien_loi']})&quot;)&#10;            &#10;            with col2:&#10;                st.write(&quot;** Score et Impact:**&quot;)&#10;                &#10;                # Gauge pour le score&#10;                fig_gauge = go.Figure(go.Indicator(&#10;                    mode = &quot;gauge+number+delta&quot;,&#10;                    value = impact['score_risque'],&#10;                    domain = {'x': [0, 1], 'y': [0, 1]},&#10;                    title = {'text': &quot;Score de Risque&quot;},&#10;                    delta = {'reference': 50},&#10;                    gauge = {&#10;                        'axis': {'range': [None, 100]},&#10;                        'bar': {'color': &quot;darkblue&quot;},&#10;                        'steps': [&#10;                            {'range': [0, 30], 'color': &quot;lightgreen&quot;},&#10;                            {'range': [30, 50], 'color': &quot;yellow&quot;},&#10;                            {'range': [50, 70], 'color': &quot;orange&quot;},&#10;                            {'range': [70, 100], 'color': &quot;red&quot;}&#10;                        ],&#10;                        'threshold': {&#10;                            'line': {'color': &quot;red&quot;, 'width': 4},&#10;                            'thickness': 0.75,&#10;                            'value': 70&#10;                        }&#10;                    }&#10;                ))&#10;                fig_gauge.update_layout(height=300)&#10;                st.plotly_chart(fig_gauge, use_container_width=True)&#10;            &#10;            # Détails des impacts&#10;            st.subheader(&quot; Impacts Détaillés&quot;)&#10;            &#10;            tab1, tab2, tab3, tab4 = st.tabs([&quot;Secteurs&quot;, &quot;Sites&quot;, &quot;Matériaux&quot;, &quot;Sanctions&quot;])&#10;            &#10;            with tab1:&#10;                if impact[&quot;secteurs_impactes&quot;]:&#10;                    for secteur in impact[&quot;secteurs_impactes&quot;]:&#10;                        st.write(f&quot;**{secteur['secteur']}**&quot;)&#10;                        st.write(f&quot;- Confiance: {secteur['confidence']}&quot;)&#10;                        st.write(f&quot;- Mots-clés détectés: {', '.join(secteur['mots_cles_detectes'])}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucun secteur spécifiquement impacté détecté&quot;)&#10;            &#10;            with tab2:&#10;                if impact[&quot;sites_impactes&quot;]:&#10;                    for site in impact[&quot;sites_impactes&quot;]:&#10;                        icon = &quot;&quot; if site[&quot;type_impact&quot;] == &quot;DIRECT&quot; else &quot;〰️&quot;&#10;                        st.write(f&quot;{icon} **{site['pays']}** ({site['type_impact']})&quot;)&#10;                        st.write(f&quot;- Raison: {site['raison']}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucun site spécifiquement impacté détecté&quot;)&#10;            &#10;            with tab3:&#10;                if impact[&quot;materiaux_impactes&quot;]:&#10;                    for materiau in impact[&quot;materiaux_impactes&quot;]:&#10;                        st.write(f&quot;**{materiau['materiau']}**&quot;)&#10;                        st.write(f&quot;- Termes détectés: {', '.join(materiau['termes_detectes'])}&quot;)&#10;                        st.write(f&quot;- Impact potentiel: {materiau['impact_potentiel']}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucun matériau spécifiquement impacté détecté&quot;)&#10;            &#10;            with tab4:&#10;                if impact[&quot;sanctions_detectees&quot;]:&#10;                    for sanction in impact[&quot;sanctions_detectees&quot;]:&#10;                        st.write(f&quot;**Type:** {sanction['type']}&quot;)&#10;                        st.write(f&quot;**Montant/Durée:** {sanction['montant_ou_duree']}&quot;)&#10;                        st.write(f&quot;**Contexte:** {sanction['contexte']}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucune sanction spécifique détectée&quot;)&#10;    &#10;    else:&#10;        st.info(&quot;Aucune réglementation analysée disponible&quot;)&#10;&#10;def show_alerts(data):&#10;    &quot;&quot;&quot;Affiche la page des alertes&quot;&quot;&quot;&#10;    &#10;    st.header(&quot; Système d'Alertes&quot;)&#10;    &#10;    if data[&quot;recent_alerts&quot;]:&#10;        # Filtres&#10;        col1, col2 = st.columns(2)&#10;        &#10;        with col1:&#10;            status_filter = st.selectbox(&#10;                &quot;Filtrer par status:&quot;,&#10;                [&quot;Toutes&quot;, &quot;UNREAD&quot;, &quot;READ&quot;]&#10;            )&#10;        &#10;        with col2:&#10;            priority_filter = st.selectbox(&#10;                &quot;Filtrer par priorité:&quot;,&#10;                [&quot;Toutes&quot;, &quot;CRITIQUE&quot;, &quot;HAUTE&quot;, &quot;MOYENNE&quot;, &quot;BASSE&quot;]&#10;            )&#10;        &#10;        # Filtrer les alertes&#10;        filtered_alerts = data[&quot;recent_alerts&quot;]&#10;        &#10;        if status_filter != &quot;Toutes&quot;:&#10;            filtered_alerts = [a for a in filtered_alerts if a.get(&quot;status&quot;) == status_filter]&#10;        &#10;        if priority_filter != &quot;Toutes&quot;:&#10;            filtered_alerts = [a for a in filtered_alerts if a.get(&quot;priority&quot;) == priority_filter]&#10;        &#10;        st.write(f&quot;**{len(filtered_alerts)} alertes affichées**&quot;)&#10;        &#10;        # Afficher les alertes&#10;        for alert in filtered_alerts:&#10;            priority_colors = {&#10;                &quot;CRITIQUE&quot;: &quot;&quot;,&#10;                &quot;HAUTE&quot;: &quot;&quot;,&#10;                &quot;MOYENNE&quot;: &quot;&quot;, &#10;                &quot;BASSE&quot;: &quot;&quot;&#10;            }&#10;            &#10;            color = priority_colors.get(alert.get(&quot;priority&quot;, &quot;&quot;), &quot;⚪&quot;)&#10;            status_icon = &quot;&quot; if alert.get(&quot;status&quot;) == &quot;UNREAD&quot; else &quot;✅&quot;&#10;            &#10;            with st.expander(f&quot;{color} {status_icon} {alert.get('message', 'Message non disponible')}&quot;):&#10;                col1, col2 = st.columns(2)&#10;                &#10;                with col1:&#10;                    st.write(f&quot;**Type:** {alert.get('type', 'N/A')}&quot;)&#10;                    st.write(f&quot;**Priorité:** {alert.get('priority', 'N/A')}&quot;)&#10;                    st.write(f&quot;**Status:** {alert.get('status', 'N/A')}&quot;)&#10;                &#10;                with col2:&#10;                    st.write(f&quot;**Créée le:** {alert.get('created_at', 'N/A')}&quot;)&#10;                    if alert.get('regulation_id'):&#10;                        st.write(f&quot;**Réglementation:** {alert['regulation_id']}&quot;)&#10;                    if alert.get('current_score'):&#10;                        st.write(f&quot;**Score actuel:** {alert['current_score']}/100&quot;)&#10;    &#10;    else:&#10;        st.info(&quot;Aucune alerte disponible&quot;)&#10;&#10;def show_monitoring():&#10;    &quot;&quot;&quot;Affiche la page de monitoring&quot;&quot;&quot;&#10;    &#10;    st.header(&quot;⚙️ Système de Monitoring&quot;)&#10;    &#10;    st.write(&quot;&quot;&quot;&#10;    Le système de monitoring surveille en permanence :&#10;    -  **Nouvelles réglementations** ajoutées à la base&#10;    -  **Modifications** des réglementations existantes  &#10;    -  **Changements de scores** de risque&#10;    -  **Génération automatique d'alertes**&#10;    &quot;&quot;&quot;)&#10;    &#10;    # Status du monitoring&#10;    st.subheader(&quot; Status du Système&quot;)&#10;    &#10;    col1, col2, col3 = st.columns(3)&#10;    &#10;    with col1:&#10;        st.metric(&quot;Monitoring&quot;, &quot;✅ Actif&quot;)&#10;    &#10;    with col2:&#10;        st.metric(&quot;Dernière vérification&quot;, &quot;Il y a 2 min&quot;)&#10;    &#10;    with col3:&#10;        st.metric(&quot;Prochaine vérification&quot;, &quot;Dans 3 min&quot;)&#10;    &#10;    # Simulation de changement&#10;    st.subheader(&quot; Test du Système&quot;)&#10;    &#10;    if st.button(&quot; Simuler un changement réglementaire&quot;):&#10;        with st.spinner(&quot;Simulation en cours...&quot;):&#10;            try:&#10;                monitor = HutchinsonMonitoringSystem()&#10;                monitor.simulate_regulation_change(&quot;32025L0001&quot;)&#10;                st.success(&quot;✅ Changement simulé! Le système détectera ce changement au prochain cycle.&quot;)&#10;            except Exception as e:&#10;                st.error(f&quot;Erreur lors de la simulation: {e}&quot;)&#10;    &#10;    # Logs récents (simulation)&#10;    st.subheader(&quot; Logs Récents&quot;)&#10;    &#10;    logs = [&#10;        {&quot;time&quot;: &quot;14:32:15&quot;, &quot;type&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Vérification des changements terminée&quot;},&#10;        {&quot;time&quot;: &quot;14:27:15&quot;, &quot;type&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Démarrage de la vérification&quot;},&#10;        {&quot;time&quot;: &quot;14:25:03&quot;, &quot;type&quot;: &quot;ALERT&quot;, &quot;message&quot;: &quot;Modification détectée: 32025L0001&quot;},&#10;        {&quot;time&quot;: &quot;14:22:15&quot;, &quot;type&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Vérification des changements terminée&quot;},&#10;    ]&#10;    &#10;    for log in logs:&#10;        color = {&quot;INFO&quot;: &quot;&quot;, &quot;ALERT&quot;: &quot;&quot;, &quot;ERROR&quot;: &quot;&quot;}.get(log[&quot;type&quot;], &quot;⚪&quot;)&#10;        st.write(f&quot;`{log['time']}` {color} {log['message']}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>