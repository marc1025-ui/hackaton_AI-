<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/monitoring_system.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitoring_system.py" />
              <option name="updatedContent" value="from hutchinson_analyzer import HutchinsonRegulatoryAnalyzer&#10;from db import db&#10;from datetime import datetime, timedelta&#10;import time&#10;import json&#10;&#10;class HutchinsonMonitoringSystem:&#10;    &quot;&quot;&quot;&#10;    Système de monitoring en temps réel pour les changements réglementaires&#10;    Surveille les modifications et met à jour automatiquement les analyses&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self.analyzer = HutchinsonRegulatoryAnalyzer()&#10;        self.regulations = db[&quot;regulations&quot;]&#10;        self.risk_analysis = db[&quot;risk_analysis&quot;]&#10;        self.alerts = db[&quot;alerts&quot;]  # Nouvelle collection pour les alertes&#10;        &#10;    def monitor_regulation_changes(self, check_interval_minutes=5):&#10;        &quot;&quot;&quot;&#10;        Surveillance continue des changements réglementaires&#10;        &#10;        Args:&#10;            check_interval_minutes (int): Intervalle de vérification en minutes&#10;        &quot;&quot;&quot;&#10;        print(f&quot; Démarrage du monitoring (vérification toutes les {check_interval_minutes} minutes)&quot;)&#10;        &#10;        while True:&#10;            try:&#10;                print(f&quot;\n⏰ {datetime.now().strftime('%H:%M:%S')} - Vérification des changements...&quot;)&#10;                &#10;                # Détecter les nouvelles réglementations&#10;                new_regulations = self._detect_new_regulations()&#10;                &#10;                # Détecter les réglementations modifiées&#10;                modified_regulations = self._detect_modified_regulations()&#10;                &#10;                # Traiter les nouvelles réglementations&#10;                if new_regulations:&#10;                    self._process_new_regulations(new_regulations)&#10;                &#10;                # Traiter les réglementations modifiées&#10;                if modified_regulations:&#10;                    self._process_modified_regulations(modified_regulations)&#10;                &#10;                # Générer des alertes si nécessaire&#10;                self._generate_alerts_if_needed()&#10;                &#10;                print(&quot;✅ Vérification terminée&quot;)&#10;                &#10;                # Attendre avant la prochaine vérification&#10;                time.sleep(check_interval_minutes * 60)&#10;                &#10;            except KeyboardInterrupt:&#10;                print(&quot;\n Arrêt du monitoring demandé&quot;)&#10;                break&#10;            except Exception as e:&#10;                print(f&quot;❌ Erreur dans le monitoring: {e}&quot;)&#10;                time.sleep(30)  # Attendre 30s avant de reprendre&#10;    &#10;    def _detect_new_regulations(self):&#10;        &quot;&quot;&quot;Détecte les nouvelles réglementations ajoutées&quot;&quot;&quot;&#10;        # Récupérer les réglementations sans analyse&#10;        analyzed_ids = set([&#10;            doc[&quot;regulation_info&quot;][&quot;id_loi&quot;] &#10;            for doc in self.risk_analysis.find({}, {&quot;regulation_info.id_loi&quot;: 1})&#10;        ])&#10;        &#10;        all_reg_ids = set([&#10;            doc[&quot;id_loi&quot;] &#10;            for doc in self.regulations.find({}, {&quot;id_loi&quot;: 1})&#10;        ])&#10;        &#10;        new_ids = all_reg_ids - analyzed_ids&#10;        &#10;        if new_ids:&#10;            new_regulations = list(self.regulations.find({&quot;id_loi&quot;: {&quot;$in&quot;: list(new_ids)}}))&#10;            return new_regulations&#10;        &#10;        return []&#10;    &#10;    def _detect_modified_regulations(self):&#10;        &quot;&quot;&quot;Détecte les réglementations modifiées récemment&quot;&quot;&quot;&#10;        # Rechercher les réglementations avec updated_at récent&#10;        recent_time = datetime.now() - timedelta(minutes=10)&#10;        &#10;        modified = list(self.regulations.find({&#10;            &quot;updated_at&quot;: {&quot;$gte&quot;: recent_time}&#10;        }))&#10;        &#10;        return modified&#10;    &#10;    def _process_new_regulations(self, new_regulations):&#10;        &quot;&quot;&quot;Traite les nouvelles réglementations&quot;&quot;&quot;&#10;        print(f&quot; {len(new_regulations)} nouvelles réglementations détectées&quot;)&#10;        &#10;        for reg in new_regulations:&#10;            try:&#10;                analysis = self.analyzer.analyze_regulation_impact_on_hutchinson(reg[&quot;id_loi&quot;])&#10;                score = analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;]&#10;                niveau = analysis[&quot;hutchinson_impact&quot;][&quot;niveau_impact&quot;]&#10;                &#10;                print(f&quot;  ✅ {reg['id_loi']}: {score}/100 ({niveau})&quot;)&#10;                &#10;                # Créer une alerte si le risque est élevé&#10;                if score &gt;= 50:&#10;                    self._create_alert(&quot;NEW_HIGH_RISK&quot;, analysis)&#10;                    &#10;            except Exception as e:&#10;                print(f&quot;  ❌ Erreur pour {reg['id_loi']}: {e}&quot;)&#10;    &#10;    def _process_modified_regulations(self, modified_regulations):&#10;        &quot;&quot;&quot;Traite les réglementations modifiées&quot;&quot;&quot;&#10;        print(f&quot; {len(modified_regulations)} réglementations modifiées détectées&quot;)&#10;        &#10;        for reg in modified_regulations:&#10;            try:&#10;                # Récupérer l'ancienne analyse&#10;                old_analysis = self.risk_analysis.find_one({&#10;                    &quot;regulation_info.id_loi&quot;: reg[&quot;id_loi&quot;]&#10;                })&#10;                &#10;                # Créer la nouvelle analyse&#10;                new_analysis = self.analyzer.analyze_regulation_impact_on_hutchinson(reg[&quot;id_loi&quot;])&#10;                &#10;                old_score = old_analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;] if old_analysis else 0&#10;                new_score = new_analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;]&#10;                &#10;                score_change = new_score - old_score&#10;                &#10;                print(f&quot;   {reg['id_loi']}: {old_score} → {new_score} (Δ{score_change:+d})&quot;)&#10;                &#10;                # Créer une alerte si le changement est significatif&#10;                if abs(score_change) &gt;= 10:&#10;                    self._create_alert(&quot;SCORE_CHANGE&quot;, new_analysis, {&#10;                        &quot;old_score&quot;: old_score,&#10;                        &quot;new_score&quot;: new_score,&#10;                        &quot;change&quot;: score_change&#10;                    })&#10;                    &#10;            except Exception as e:&#10;                print(f&quot;  ❌ Erreur pour {reg['id_loi']}: {e}&quot;)&#10;    &#10;    def _create_alert(self, alert_type, analysis, extra_data=None):&#10;        &quot;&quot;&quot;Crée une alerte dans la base de données&quot;&quot;&quot;&#10;        &#10;        alert = {&#10;            &quot;type&quot;: alert_type,&#10;            &quot;regulation_id&quot;: analysis[&quot;regulation_info&quot;][&quot;id_loi&quot;],&#10;            &quot;regulation_name&quot;: analysis[&quot;regulation_info&quot;][&quot;nom_loi&quot;],&#10;            &quot;current_score&quot;: analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;],&#10;            &quot;impact_level&quot;: analysis[&quot;hutchinson_impact&quot;][&quot;niveau_impact&quot;],&#10;            &quot;created_at&quot;: datetime.now(),&#10;            &quot;status&quot;: &quot;UNREAD&quot;,&#10;            &quot;priority&quot;: self._determine_alert_priority(analysis[&quot;hutchinson_impact&quot;][&quot;score_risque&quot;])&#10;        }&#10;        &#10;        if extra_data:&#10;            alert.update(extra_data)&#10;        &#10;        # Ajouter des détails spécifiques selon le type d'alerte&#10;        if alert_type == &quot;NEW_HIGH_RISK&quot;:&#10;            alert[&quot;message&quot;] = f&quot;Nouvelle réglementation à haut risque détectée: {analysis['regulation_info']['nom_loi']}&quot;&#10;        elif alert_type == &quot;SCORE_CHANGE&quot;:&#10;            alert[&quot;message&quot;] = f&quot;Changement significatif de score pour {analysis['regulation_info']['nom_loi']}: {extra_data['old_score']} → {extra_data['new_score']}&quot;&#10;        &#10;        self.alerts.insert_one(alert)&#10;        print(f&quot;   ALERTE créée: {alert['message']}&quot;)&#10;    &#10;    def _determine_alert_priority(self, score):&#10;        &quot;&quot;&quot;Détermine la priorité de l'alerte basée sur le score&quot;&quot;&quot;&#10;        if score &gt;= 70:&#10;            return &quot;CRITIQUE&quot;&#10;        elif score &gt;= 50:&#10;            return &quot;HAUTE&quot;&#10;        elif score &gt;= 30:&#10;            return &quot;MOYENNE&quot;&#10;        else:&#10;            return &quot;BASSE&quot;&#10;    &#10;    def _generate_alerts_if_needed(self):&#10;        &quot;&quot;&quot;Génère des alertes basées sur des règles métier&quot;&quot;&quot;&#10;        # Exemple: Alerte si plus de 3 réglementations critiques&#10;        critical_count = self.risk_analysis.count_documents({&#10;            &quot;hutchinson_impact.niveau_impact&quot;: &quot;CRITIQUE&quot;&#10;        })&#10;        &#10;        if critical_count &gt;= 3:&#10;            # Vérifier si cette alerte n'existe pas déjà&#10;            existing_alert = self.alerts.find_one({&#10;                &quot;type&quot;: &quot;MULTIPLE_CRITICAL&quot;,&#10;                &quot;created_at&quot;: {&quot;$gte&quot;: datetime.now() - timedelta(days=1)}&#10;            })&#10;            &#10;            if not existing_alert:&#10;                alert = {&#10;                    &quot;type&quot;: &quot;MULTIPLE_CRITICAL&quot;,&#10;                    &quot;message&quot;: f&quot;Attention: {critical_count} réglementations critiques détectées&quot;,&#10;                    &quot;count&quot;: critical_count,&#10;                    &quot;created_at&quot;: datetime.now(),&#10;                    &quot;status&quot;: &quot;UNREAD&quot;,&#10;                    &quot;priority&quot;: &quot;CRITIQUE&quot;&#10;                }&#10;                self.alerts.insert_one(alert)&#10;                print(f&quot;   ALERTE SYSTÈME: {alert['message']}&quot;)&#10;    &#10;    def get_unread_alerts(self):&#10;        &quot;&quot;&quot;Récupère toutes les alertes non lues&quot;&quot;&quot;&#10;        return list(self.alerts.find({&quot;status&quot;: &quot;UNREAD&quot;}).sort(&quot;created_at&quot;, -1))&#10;    &#10;    def mark_alert_as_read(self, alert_id):&#10;        &quot;&quot;&quot;Marque une alerte comme lue&quot;&quot;&quot;&#10;        self.alerts.update_one(&#10;            {&quot;_id&quot;: alert_id},&#10;            {&quot;$set&quot;: {&quot;status&quot;: &quot;READ&quot;, &quot;read_at&quot;: datetime.now()}}&#10;        )&#10;    &#10;    def get_dashboard_data(self):&#10;        &quot;&quot;&quot;Récupère les données pour le dashboard Streamlit&quot;&quot;&quot;&#10;        &#10;        # Statistiques générales&#10;        total_regulations = self.regulations.count_documents({})&#10;        analyzed_regulations = self.risk_analysis.count_documents({})&#10;        &#10;        # Répartition par niveau de risque&#10;        risk_distribution = {}&#10;        for level in [&quot;CRITIQUE&quot;, &quot;ELEVE&quot;, &quot;MOYEN&quot;, &quot;FAIBLE&quot;]:&#10;            count = self.risk_analysis.count_documents({&#10;                &quot;hutchinson_impact.niveau_impact&quot;: level&#10;            })&#10;            risk_distribution[level] = count&#10;        &#10;        # Top 5 des réglementations les plus risquées&#10;        top_risks = list(self.risk_analysis.find({}).sort(&#10;            &quot;hutchinson_impact.score_risque&quot;, -1&#10;        ).limit(5))&#10;        &#10;        # Alertes récentes&#10;        recent_alerts = list(self.alerts.find({}).sort(&quot;created_at&quot;, -1).limit(10))&#10;        &#10;        # Secteurs les plus impactés&#10;        sector_impacts = {}&#10;        for analysis in self.risk_analysis.find({}):&#10;            for sector_impact in analysis[&quot;hutchinson_impact&quot;][&quot;secteurs_impactes&quot;]:&#10;                sector = sector_impact[&quot;secteur&quot;]&#10;                sector_impacts[sector] = sector_impacts.get(sector, 0) + 1&#10;        &#10;        return {&#10;            &quot;total_regulations&quot;: total_regulations,&#10;            &quot;analyzed_regulations&quot;: analyzed_regulations,&#10;            &quot;risk_distribution&quot;: risk_distribution,&#10;            &quot;top_risks&quot;: top_risks,&#10;            &quot;recent_alerts&quot;: recent_alerts,&#10;            &quot;sector_impacts&quot;: sector_impacts,&#10;            &quot;last_update&quot;: datetime.now()&#10;        }&#10;    &#10;    def simulate_regulation_change(self, regulation_id):&#10;        &quot;&quot;&quot;Simule un changement de réglementation pour tester les alertes&quot;&quot;&quot;&#10;        print(f&quot; Simulation d'un changement pour {regulation_id}&quot;)&#10;        &#10;        # Marquer la réglementation comme modifiée&#10;        self.regulations.update_one(&#10;            {&quot;id_loi&quot;: regulation_id},&#10;            {&quot;$set&quot;: {&quot;updated_at&quot;: datetime.now()}}&#10;        )&#10;        &#10;        print(&quot;✅ Réglementation marquée comme modifiée&quot;)&#10;        print(&quot; Le système de monitoring détectera ce changement au prochain cycle&quot;)&#10;&#10;def demo_monitoring_system():&#10;    &quot;&quot;&quot;Démonstration du système de monitoring&quot;&quot;&quot;&#10;    &#10;    print(&quot; SYSTÈME DE MONITORING HUTCHINSON&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    monitor = HutchinsonMonitoringSystem()&#10;    &#10;    # Simuler un changement pour démonstration&#10;    print(&quot; Simulation d'un changement réglementaire...&quot;)&#10;    monitor.simulate_regulation_change(&quot;32025L0001&quot;)&#10;    &#10;    # Vérification manuelle des changements&#10;    print(&quot;\n Vérification manuelle des changements...&quot;)&#10;    new_regs = monitor._detect_new_regulations()&#10;    modified_regs = monitor._detect_modified_regulations()&#10;    &#10;    print(f&quot;Nouvelles réglementations: {len(new_regs)}&quot;)&#10;    print(f&quot;Réglementations modifiées: {len(modified_regs)}&quot;)&#10;    &#10;    if modified_regs:&#10;        monitor._process_modified_regulations(modified_regs)&#10;    &#10;    # Afficher les alertes&#10;    print(&quot;\n ALERTES:&quot;)&#10;    alerts = monitor.get_unread_alerts()&#10;    if alerts:&#10;        for alert in alerts:&#10;            print(f&quot;  • [{alert['priority']}] {alert['message']}&quot;)&#10;    else:&#10;        print(&quot;  ✅ Aucune alerte&quot;)&#10;    &#10;    # Données du dashboard&#10;    print(&quot;\n DONNÉES DASHBOARD:&quot;)&#10;    dashboard_data = monitor.get_dashboard_data()&#10;    print(f&quot;  Total réglementations: {dashboard_data['total_regulations']}&quot;)&#10;    print(f&quot;  Analysées: {dashboard_data['analyzed_regulations']}&quot;)&#10;    print(f&quot;  Répartition risques: {dashboard_data['risk_distribution']}&quot;)&#10;    print(f&quot;  Secteurs impactés: {dashboard_data['sector_impacts']}&quot;)&#10;    &#10;    print(&quot;\n Pour démarrer le monitoring en continu:&quot;)&#10;    print(&quot;  monitor.monitor_regulation_changes(check_interval_minutes=5)&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    demo_monitoring_system()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="originalContent" value="pymongo==4.6.0&#10;python-dotenv==1.0.0&#10;sentence-transformers&#10;transformers&#10;torch&#10;requests&#10;" />
              <option name="updatedContent" value="pymongo==4.6.0&#10;python-dotenv==1.0.0&#10;sentence-transformers&#10;transformers&#10;torch&#10;requests&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/streamlit_app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/streamlit_app.py" />
              <option name="updatedContent" value="import streamlit as st&#10;import pandas as pd&#10;import plotly.express as px&#10;import plotly.graph_objects as go&#10;from datetime import datetime, timedelta&#10;from monitoring_system import HutchinsonMonitoringSystem&#10;from hutchinson_analyzer import HutchinsonRegulatoryAnalyzer&#10;import json&#10;&#10;# Configuration de la page&#10;st.set_page_config(&#10;    page_title=&quot;Hutchinson - Surveillance Réglementaire&quot;,&#10;    page_icon=&quot;&quot;,&#10;    layout=&quot;wide&quot;,&#10;    initial_sidebar_state=&quot;expanded&quot;&#10;)&#10;&#10;# Cache des données pour éviter de recharger à chaque fois&#10;@st.cache_data(ttl=300)  # Cache pendant 5 minutes&#10;def load_dashboard_data():&#10;    &quot;&quot;&quot;Charge les données du dashboard&quot;&quot;&quot;&#10;    monitor = HutchinsonMonitoringSystem()&#10;    return monitor.get_dashboard_data()&#10;&#10;@st.cache_resource&#10;def get_analyzer():&#10;    &quot;&quot;&quot;Récupère l'analyseur (en cache)&quot;&quot;&quot;&#10;    return HutchinsonRegulatoryAnalyzer()&#10;&#10;def main():&#10;    # Header&#10;    st.title(&quot; Hutchinson - Surveillance Réglementaire AI&quot;)&#10;    st.markdown(&quot;**Système d'anticipation des risques réglementaires avec IA**&quot;)&#10;    &#10;    # Sidebar&#10;    st.sidebar.title(&quot; Navigation&quot;)&#10;    page = st.sidebar.selectbox(&#10;        &quot;Choisir une page&quot;,&#10;        [&quot; Dashboard&quot;, &quot; Analyse Détaillée&quot;, &quot; Alertes&quot;, &quot;⚙️ Monitoring&quot;]&#10;    )&#10;    &#10;    # Charger les données&#10;    try:&#10;        dashboard_data = load_dashboard_data()&#10;        analyzer = get_analyzer()&#10;    except Exception as e:&#10;        st.error(f&quot;Erreur de connexion à la base de données: {e}&quot;)&#10;        st.stop()&#10;    &#10;    # Navigation des pages&#10;    if page == &quot; Dashboard&quot;:&#10;        show_dashboard(dashboard_data)&#10;    elif page == &quot; Analyse Détaillée&quot;:&#10;        show_detailed_analysis(analyzer, dashboard_data)&#10;    elif page == &quot; Alertes&quot;:&#10;        show_alerts(dashboard_data)&#10;    elif page == &quot;⚙️ Monitoring&quot;:&#10;        show_monitoring()&#10;&#10;def show_dashboard(data):&#10;    &quot;&quot;&quot;Affiche le dashboard principal&quot;&quot;&quot;&#10;    &#10;    st.header(&quot; Dashboard Principal&quot;)&#10;    &#10;    # Métriques principales&#10;    col1, col2, col3, col4 = st.columns(4)&#10;    &#10;    with col1:&#10;        st.metric(&#10;            &quot;Total Réglementations&quot;,&#10;            data[&quot;total_regulations&quot;],&#10;            delta=None&#10;        )&#10;    &#10;    with col2:&#10;        st.metric(&#10;            &quot;Analysées&quot;,&#10;            data[&quot;analyzed_regulations&quot;],&#10;            delta=f&quot;{data['analyzed_regulations'] - data['total_regulations']}&quot; if data['analyzed_regulations'] != data['total_regulations'] else None&#10;        )&#10;    &#10;    with col3:&#10;        critical_count = data[&quot;risk_distribution&quot;].get(&quot;CRITIQUE&quot;, 0)&#10;        high_count = data[&quot;risk_distribution&quot;].get(&quot;ELEVE&quot;, 0)&#10;        st.metric(&#10;            &quot;Risques Élevés/Critiques&quot;,&#10;            critical_count + high_count,&#10;            delta=None&#10;        )&#10;    &#10;    with col4:&#10;        st.metric(&#10;            &quot;Alertes Récentes&quot;,&#10;            len([a for a in data[&quot;recent_alerts&quot;] if a.get(&quot;status&quot;) == &quot;UNREAD&quot;]),&#10;            delta=None&#10;        )&#10;    &#10;    # Graphiques&#10;    col1, col2 = st.columns(2)&#10;    &#10;    with col1:&#10;        st.subheader(&quot; Répartition des Risques&quot;)&#10;        if data[&quot;risk_distribution&quot;]:&#10;            # Graphique en camembert&#10;            risk_df = pd.DataFrame(&#10;                list(data[&quot;risk_distribution&quot;].items()),&#10;                columns=[&quot;Niveau&quot;, &quot;Nombre&quot;]&#10;            )&#10;            risk_df = risk_df[risk_df[&quot;Nombre&quot;] &gt; 0]  # Retirer les 0&#10;            &#10;            if not risk_df.empty:&#10;                colors = {&#10;                    &quot;CRITIQUE&quot;: &quot;#FF4B4B&quot;,&#10;                    &quot;ELEVE&quot;: &quot;#FF8C00&quot;, &#10;                    &quot;MOYEN&quot;: &quot;#FFD700&quot;,&#10;                    &quot;FAIBLE&quot;: &quot;#32CD32&quot;&#10;                }&#10;                &#10;                fig_pie = px.pie(&#10;                    risk_df, &#10;                    values=&quot;Nombre&quot;, &#10;                    names=&quot;Niveau&quot;,&#10;                    color=&quot;Niveau&quot;,&#10;                    color_discrete_map=colors&#10;                )&#10;                st.plotly_chart(fig_pie, use_container_width=True)&#10;            else:&#10;                st.info(&quot;Aucune donnée de risque disponible&quot;)&#10;        else:&#10;            st.info(&quot;Aucune donnée de risque disponible&quot;)&#10;    &#10;    with col2:&#10;        st.subheader(&quot; Secteurs Impactés&quot;)&#10;        if data[&quot;sector_impacts&quot;]:&#10;            sector_df = pd.DataFrame(&#10;                list(data[&quot;sector_impacts&quot;].items()),&#10;                columns=[&quot;Secteur&quot;, &quot;Nombre d'Impacts&quot;]&#10;            )&#10;            &#10;            fig_bar = px.bar(&#10;                sector_df,&#10;                x=&quot;Secteur&quot;,&#10;                y=&quot;Nombre d'Impacts&quot;,&#10;                color=&quot;Nombre d'Impacts&quot;,&#10;                color_continuous_scale=&quot;Blues&quot;&#10;            )&#10;            fig_bar.update_layout(showlegend=False)&#10;            st.plotly_chart(fig_bar, use_container_width=True)&#10;        else:&#10;            st.info(&quot;Aucun impact sectoriel détecté&quot;)&#10;    &#10;    # Top risques&#10;    st.subheader(&quot;⚠️ Top 5 - Réglementations les Plus Risquées&quot;)&#10;    &#10;    if data[&quot;top_risks&quot;]:&#10;        for i, risk in enumerate(data[&quot;top_risks&quot;], 1):&#10;            reg_info = risk[&quot;regulation_info&quot;]&#10;            impact = risk[&quot;hutchinson_impact&quot;]&#10;            &#10;            # Couleur selon le niveau&#10;            color_map = {&#10;                &quot;CRITIQUE&quot;: &quot;&quot;,&#10;                &quot;ELEVE&quot;: &quot;&quot;, &#10;                &quot;MOYEN&quot;: &quot;&quot;,&#10;                &quot;FAIBLE&quot;: &quot;&quot;&#10;            }&#10;            &#10;            color = color_map.get(impact[&quot;niveau_impact&quot;], &quot;⚪&quot;)&#10;            &#10;            with st.expander(f&quot;{i}. {color} {reg_info['nom_loi'][:80]}... - Score: {impact['score_risque']}/100&quot;):&#10;                col1, col2 = st.columns(2)&#10;                &#10;                with col1:&#10;                    st.write(f&quot;**ID:** {reg_info['id_loi']}&quot;)&#10;                    st.write(f&quot;**Type:** {reg_info['type']}&quot;)&#10;                    st.write(f&quot;**Date:** {reg_info['date_publication']}&quot;)&#10;                    st.write(f&quot;**Pays:** {', '.join(reg_info['pays_concernes'])}&quot;)&#10;                &#10;                with col2:&#10;                    st.write(f&quot;**Niveau d'Impact:** {impact['niveau_impact']}&quot;)&#10;                    st.write(f&quot;**Secteurs Impactés:** {len(impact['secteurs_impactes'])}&quot;)&#10;                    st.write(f&quot;**Sites Impactés:** {len(impact['sites_impactes'])}&quot;)&#10;                    st.write(f&quot;**Sanctions Détectées:** {len(impact['sanctions_detectees'])}&quot;)&#10;                &#10;                if reg_info.get('lien_loi'):&#10;                    st.markdown(f&quot; [Voir la réglementation complète]({reg_info['lien_loi']})&quot;)&#10;    else:&#10;        st.info(&quot;Aucune analyse de risque disponible&quot;)&#10;    &#10;    # Dernière mise à jour&#10;    st.caption(f&quot;Dernière mise à jour: {data['last_update'].strftime('%d/%m/%Y %H:%M:%S')}&quot;)&#10;&#10;def show_detailed_analysis(analyzer, data):&#10;    &quot;&quot;&quot;Affiche la page d'analyse détaillée&quot;&quot;&quot;&#10;    &#10;    st.header(&quot; Analyse Détaillée&quot;)&#10;    &#10;    # Sélection d'une réglementation&#10;    if data[&quot;top_risks&quot;]:&#10;        regulation_options = {&#10;            f&quot;{risk['regulation_info']['id_loi']} - {risk['regulation_info']['nom_loi'][:50]}...&quot;: risk['regulation_info']['id_loi']&#10;            for risk in data[&quot;top_risks&quot;]&#10;        }&#10;        &#10;        selected_reg_display = st.selectbox(&#10;            &quot;Choisir une réglementation à analyser:&quot;,&#10;            list(regulation_options.keys())&#10;        )&#10;        &#10;        selected_reg_id = regulation_options[selected_reg_display]&#10;        &#10;        # Bouton pour re-analyser&#10;        if st.button(&quot; Re-analyser cette réglementation&quot;):&#10;            with st.spinner(&quot;Analyse en cours...&quot;):&#10;                try:&#10;                    analysis = analyzer.analyze_regulation_impact_on_hutchinson(selected_reg_id)&#10;                    st.success(&quot;✅ Analyse terminée!&quot;)&#10;                    &#10;                    # Afficher le rapport formaté&#10;                    formatted_report = analyzer.format_analysis_report(analysis)&#10;                    st.text(formatted_report)&#10;                    &#10;                except Exception as e:&#10;                    st.error(f&quot;Erreur lors de l'analyse: {e}&quot;)&#10;        &#10;        # Afficher l'analyse existante&#10;        existing_analysis = None&#10;        for risk in data[&quot;top_risks&quot;]:&#10;            if risk[&quot;regulation_info&quot;][&quot;id_loi&quot;] == selected_reg_id:&#10;                existing_analysis = risk&#10;                break&#10;        &#10;        if existing_analysis:&#10;            st.subheader(&quot; Analyse Actuelle&quot;)&#10;            &#10;            reg_info = existing_analysis[&quot;regulation_info&quot;]&#10;            impact = existing_analysis[&quot;hutchinson_impact&quot;]&#10;            &#10;            # Informations générales&#10;            col1, col2 = st.columns(2)&#10;            &#10;            with col1:&#10;                st.write(&quot;** Informations Réglementation:**&quot;)&#10;                st.write(f&quot;- **ID:** {reg_info['id_loi']}&quot;)&#10;                st.write(f&quot;- **Type:** {reg_info['type']}&quot;)&#10;                st.write(f&quot;- **Date publication:** {reg_info['date_publication']}&quot;)&#10;                st.write(f&quot;- **Pays concernés:** {', '.join(reg_info['pays_concernes'])}&quot;)&#10;                &#10;                if reg_info.get('lien_loi'):&#10;                    st.markdown(f&quot; [Lien officiel]({reg_info['lien_loi']})&quot;)&#10;            &#10;            with col2:&#10;                st.write(&quot;** Score et Impact:**&quot;)&#10;                &#10;                # Gauge pour le score&#10;                fig_gauge = go.Figure(go.Indicator(&#10;                    mode = &quot;gauge+number+delta&quot;,&#10;                    value = impact['score_risque'],&#10;                    domain = {'x': [0, 1], 'y': [0, 1]},&#10;                    title = {'text': &quot;Score de Risque&quot;},&#10;                    delta = {'reference': 50},&#10;                    gauge = {&#10;                        'axis': {'range': [None, 100]},&#10;                        'bar': {'color': &quot;darkblue&quot;},&#10;                        'steps': [&#10;                            {'range': [0, 30], 'color': &quot;lightgreen&quot;},&#10;                            {'range': [30, 50], 'color': &quot;yellow&quot;},&#10;                            {'range': [50, 70], 'color': &quot;orange&quot;},&#10;                            {'range': [70, 100], 'color': &quot;red&quot;}&#10;                        ],&#10;                        'threshold': {&#10;                            'line': {'color': &quot;red&quot;, 'width': 4},&#10;                            'thickness': 0.75,&#10;                            'value': 70&#10;                        }&#10;                    }&#10;                ))&#10;                fig_gauge.update_layout(height=300)&#10;                st.plotly_chart(fig_gauge, use_container_width=True)&#10;            &#10;            # Détails des impacts&#10;            st.subheader(&quot; Impacts Détaillés&quot;)&#10;            &#10;            tab1, tab2, tab3, tab4 = st.tabs([&quot;Secteurs&quot;, &quot;Sites&quot;, &quot;Matériaux&quot;, &quot;Sanctions&quot;])&#10;            &#10;            with tab1:&#10;                if impact[&quot;secteurs_impactes&quot;]:&#10;                    for secteur in impact[&quot;secteurs_impactes&quot;]:&#10;                        st.write(f&quot;**{secteur['secteur']}**&quot;)&#10;                        st.write(f&quot;- Confiance: {secteur['confidence']}&quot;)&#10;                        st.write(f&quot;- Mots-clés détectés: {', '.join(secteur['mots_cles_detectes'])}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucun secteur spécifiquement impacté détecté&quot;)&#10;            &#10;            with tab2:&#10;                if impact[&quot;sites_impactes&quot;]:&#10;                    for site in impact[&quot;sites_impactes&quot;]:&#10;                        icon = &quot;&quot; if site[&quot;type_impact&quot;] == &quot;DIRECT&quot; else &quot;〰️&quot;&#10;                        st.write(f&quot;{icon} **{site['pays']}** ({site['type_impact']})&quot;)&#10;                        st.write(f&quot;- Raison: {site['raison']}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucun site spécifiquement impacté détecté&quot;)&#10;            &#10;            with tab3:&#10;                if impact[&quot;materiaux_impactes&quot;]:&#10;                    for materiau in impact[&quot;materiaux_impactes&quot;]:&#10;                        st.write(f&quot;**{materiau['materiau']}**&quot;)&#10;                        st.write(f&quot;- Termes détectés: {', '.join(materiau['termes_detectes'])}&quot;)&#10;                        st.write(f&quot;- Impact potentiel: {materiau['impact_potentiel']}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucun matériau spécifiquement impacté détecté&quot;)&#10;            &#10;            with tab4:&#10;                if impact[&quot;sanctions_detectees&quot;]:&#10;                    for sanction in impact[&quot;sanctions_detectees&quot;]:&#10;                        st.write(f&quot;**Type:** {sanction['type']}&quot;)&#10;                        st.write(f&quot;**Montant/Durée:** {sanction['montant_ou_duree']}&quot;)&#10;                        st.write(f&quot;**Contexte:** {sanction['contexte']}&quot;)&#10;                        st.write(&quot;---&quot;)&#10;                else:&#10;                    st.info(&quot;Aucune sanction spécifique détectée&quot;)&#10;    &#10;    else:&#10;        st.info(&quot;Aucune réglementation analysée disponible&quot;)&#10;&#10;def show_alerts(data):&#10;    &quot;&quot;&quot;Affiche la page des alertes&quot;&quot;&quot;&#10;    &#10;    st.header(&quot; Système d'Alertes&quot;)&#10;    &#10;    if data[&quot;recent_alerts&quot;]:&#10;        # Filtres&#10;        col1, col2 = st.columns(2)&#10;        &#10;        with col1:&#10;            status_filter = st.selectbox(&#10;                &quot;Filtrer par status:&quot;,&#10;                [&quot;Toutes&quot;, &quot;UNREAD&quot;, &quot;READ&quot;]&#10;            )&#10;        &#10;        with col2:&#10;            priority_filter = st.selectbox(&#10;                &quot;Filtrer par priorité:&quot;,&#10;                [&quot;Toutes&quot;, &quot;CRITIQUE&quot;, &quot;HAUTE&quot;, &quot;MOYENNE&quot;, &quot;BASSE&quot;]&#10;            )&#10;        &#10;        # Filtrer les alertes&#10;        filtered_alerts = data[&quot;recent_alerts&quot;]&#10;        &#10;        if status_filter != &quot;Toutes&quot;:&#10;            filtered_alerts = [a for a in filtered_alerts if a.get(&quot;status&quot;) == status_filter]&#10;        &#10;        if priority_filter != &quot;Toutes&quot;:&#10;            filtered_alerts = [a for a in filtered_alerts if a.get(&quot;priority&quot;) == priority_filter]&#10;        &#10;        st.write(f&quot;**{len(filtered_alerts)} alertes affichées**&quot;)&#10;        &#10;        # Afficher les alertes&#10;        for alert in filtered_alerts:&#10;            priority_colors = {&#10;                &quot;CRITIQUE&quot;: &quot;&quot;,&#10;                &quot;HAUTE&quot;: &quot;&quot;,&#10;                &quot;MOYENNE&quot;: &quot;&quot;, &#10;                &quot;BASSE&quot;: &quot;&quot;&#10;            }&#10;            &#10;            color = priority_colors.get(alert.get(&quot;priority&quot;, &quot;&quot;), &quot;⚪&quot;)&#10;            status_icon = &quot;&quot; if alert.get(&quot;status&quot;) == &quot;UNREAD&quot; else &quot;✅&quot;&#10;            &#10;            with st.expander(f&quot;{color} {status_icon} {alert.get('message', 'Message non disponible')}&quot;):&#10;                col1, col2 = st.columns(2)&#10;                &#10;                with col1:&#10;                    st.write(f&quot;**Type:** {alert.get('type', 'N/A')}&quot;)&#10;                    st.write(f&quot;**Priorité:** {alert.get('priority', 'N/A')}&quot;)&#10;                    st.write(f&quot;**Status:** {alert.get('status', 'N/A')}&quot;)&#10;                &#10;                with col2:&#10;                    st.write(f&quot;**Créée le:** {alert.get('created_at', 'N/A')}&quot;)&#10;                    if alert.get('regulation_id'):&#10;                        st.write(f&quot;**Réglementation:** {alert['regulation_id']}&quot;)&#10;                    if alert.get('current_score'):&#10;                        st.write(f&quot;**Score actuel:** {alert['current_score']}/100&quot;)&#10;    &#10;    else:&#10;        st.info(&quot;Aucune alerte disponible&quot;)&#10;&#10;def show_monitoring():&#10;    &quot;&quot;&quot;Affiche la page de monitoring&quot;&quot;&quot;&#10;    &#10;    st.header(&quot;⚙️ Système de Monitoring&quot;)&#10;    &#10;    st.write(&quot;&quot;&quot;&#10;    Le système de monitoring surveille en permanence :&#10;    -  **Nouvelles réglementations** ajoutées à la base&#10;    -  **Modifications** des réglementations existantes  &#10;    -  **Changements de scores** de risque&#10;    -  **Génération automatique d'alertes**&#10;    &quot;&quot;&quot;)&#10;    &#10;    # Status du monitoring&#10;    st.subheader(&quot; Status du Système&quot;)&#10;    &#10;    col1, col2, col3 = st.columns(3)&#10;    &#10;    with col1:&#10;        st.metric(&quot;Monitoring&quot;, &quot;✅ Actif&quot;)&#10;    &#10;    with col2:&#10;        st.metric(&quot;Dernière vérification&quot;, &quot;Il y a 2 min&quot;)&#10;    &#10;    with col3:&#10;        st.metric(&quot;Prochaine vérification&quot;, &quot;Dans 3 min&quot;)&#10;    &#10;    # Simulation de changement&#10;    st.subheader(&quot; Test du Système&quot;)&#10;    &#10;    if st.button(&quot; Simuler un changement réglementaire&quot;):&#10;        with st.spinner(&quot;Simulation en cours...&quot;):&#10;            try:&#10;                monitor = HutchinsonMonitoringSystem()&#10;                monitor.simulate_regulation_change(&quot;32025L0001&quot;)&#10;                st.success(&quot;✅ Changement simulé! Le système détectera ce changement au prochain cycle.&quot;)&#10;            except Exception as e:&#10;                st.error(f&quot;Erreur lors de la simulation: {e}&quot;)&#10;    &#10;    # Logs récents (simulation)&#10;    st.subheader(&quot; Logs Récents&quot;)&#10;    &#10;    logs = [&#10;        {&quot;time&quot;: &quot;14:32:15&quot;, &quot;type&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Vérification des changements terminée&quot;},&#10;        {&quot;time&quot;: &quot;14:27:15&quot;, &quot;type&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Démarrage de la vérification&quot;},&#10;        {&quot;time&quot;: &quot;14:25:03&quot;, &quot;type&quot;: &quot;ALERT&quot;, &quot;message&quot;: &quot;Modification détectée: 32025L0001&quot;},&#10;        {&quot;time&quot;: &quot;14:22:15&quot;, &quot;type&quot;: &quot;INFO&quot;, &quot;message&quot;: &quot;Vérification des changements terminée&quot;},&#10;    ]&#10;    &#10;    for log in logs:&#10;        color = {&quot;INFO&quot;: &quot;&quot;, &quot;ALERT&quot;: &quot;&quot;, &quot;ERROR&quot;: &quot;&quot;}.get(log[&quot;type&quot;], &quot;⚪&quot;)&#10;        st.write(f&quot;`{log['time']}` {color} {log['message']}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_real_data.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_real_data.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Test avec les données RÉELLES de la collection MongoDB&#10;Analyse les vraies réglementations stockées dans votre base de données&#10;&quot;&quot;&quot;&#10;&#10;from pymongo import MongoClient&#10;from datetime import datetime&#10;&#10;def test_with_real_data():&#10;    &quot;&quot;&quot;Test avec les données réelles de MongoDB&quot;&quot;&quot;&#10;    &#10;    print(&quot; TEST AVEC LES DONNÉES RÉELLES DE LA COLLECTION&quot;)&#10;    print(&quot;=&quot; * 60)&#10;    &#10;    try:&#10;        # Connexion à la vraie base MongoDB&#10;        CONNECTION_STRING = &quot;mongodb+srv://marcjuniorh29:qTdh0MSrMZRkLM2l@clustermarc.os3r2.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=ClusterMarc&quot;&#10;        client = MongoClient(CONNECTION_STRING)&#10;        db = client[&quot;hackathon_regulations&quot;]&#10;        &#10;        print(&quot;✅ Connexion MongoDB établie&quot;)&#10;        &#10;        # Vérifier les collections disponibles&#10;        collections = db.list_collection_names()&#10;        print(f&quot; Collections disponibles: {collections}&quot;)&#10;        &#10;        # Récupérer toutes les réglementations réelles&#10;        print(&quot;\n Récupération des réglementations réelles...&quot;)&#10;        regulations = list(db.regulations.find())&#10;        &#10;        if not regulations:&#10;            print(&quot;❌ Aucune réglementation trouvée dans la collection&quot;)&#10;            print(&quot; Assurez-vous d'avoir d'abord exécuté mongodb_setup.py&quot;)&#10;            return False&#10;        &#10;        print(f&quot;✅ {len(regulations)} réglementations trouvées dans la base&quot;)&#10;        &#10;        # Afficher les réglementations disponibles&#10;        print(f&quot;\n RÉGLEMENTATIONS DANS LA BASE:&quot;)&#10;        print(&quot;-&quot; * 50)&#10;        for i, reg in enumerate(regulations, 1):&#10;            print(f&quot;{i}. {reg.get('nom_loi', 'Nom non disponible')}&quot;)&#10;            print(f&quot;   ID: {reg.get('id_loi', 'N/A')}&quot;)&#10;            print(f&quot;   Type: {reg.get('type', 'N/A')}&quot;)&#10;            print(f&quot;   Pays: {reg.get('pays_concernes', 'N/A')}&quot;)&#10;            print(f&quot;   Date effet: {reg.get('date_effet', 'N/A')}&quot;)&#10;            print()&#10;        &#10;        # Récupérer le profil Hutchinson réel&#10;        print(&quot; Récupération du profil Hutchinson...&quot;)&#10;        hutchinson = db.hutchinson.find_one()&#10;        &#10;        if not hutchinson:&#10;            print(&quot;❌ Profil Hutchinson non trouvé&quot;)&#10;            return False&#10;        &#10;        print(&quot;✅ Profil Hutchinson récupéré&quot;)&#10;        print(f&quot;   Secteurs: {hutchinson.get('company_info', {}).get('sectors', 'N/A')}&quot;)&#10;        print(f&quot;   Géographie: {len(hutchinson.get('geographical_presence', []))} pays&quot;)&#10;        &#10;        # Import du système RAG + LLM&#10;        from rag_with_llm import RegulatoryRiskRAGWithLLM&#10;        print(&quot;\n Initialisation du système RAG + LLM...&quot;)&#10;        &#10;        # Initialiser en mode règles&#10;        rag_system = RegulatoryRiskRAGWithLLM(&quot;rules&quot;)&#10;        print(&quot;✅ Système initialisé&quot;)&#10;        &#10;        # Calculer les scores de matching avec les données réelles&#10;        print(&quot;\n ANALYSE DE MATCHING AVEC DONNÉES RÉELLES:&quot;)&#10;        print(&quot;=&quot; * 50)&#10;        &#10;        matching_results = []&#10;        &#10;        for reg in regulations:&#10;            score_details = calculate_real_matching_score(reg, hutchinson)&#10;            matching_results.append({&#10;                'regulation': reg,&#10;                'total_score': score_details['total_score'],&#10;                'score_details': score_details&#10;            })&#10;        &#10;        # Trier par score décroissant&#10;        matching_results.sort(key=lambda x: x['total_score'], reverse=True)&#10;        &#10;        # Classifier par niveaux d'impact&#10;        high_impact = [r for r in matching_results if r['total_score'] &gt;= 0.7]&#10;        medium_impact = [r for r in matching_results if 0.5 &lt;= r['total_score'] &lt; 0.7]&#10;        low_impact = [r for r in matching_results if 0.3 &lt;= r['total_score'] &lt; 0.5]&#10;        negligible = [r for r in matching_results if r['total_score'] &lt; 0.3]&#10;        &#10;        # Afficher les résultats du matching&#10;        print(f&quot; RÉSULTATS DU MATCHING:&quot;)&#10;        print(f&quot;    Impact TRÈS ÉLEVÉ: {len(high_impact)} lois (score ≥ 0.7)&quot;)&#10;        print(f&quot;    Impact MOYEN: {len(medium_impact)} lois (0.5 ≤ score &lt; 0.7)&quot;)&#10;        print(f&quot;    Impact FAIBLE: {len(low_impact)} lois (0.3 ≤ score &lt; 0.5)&quot;)&#10;        print(f&quot;    Impact NÉGLIGEABLE: {len(negligible)} lois (score &lt; 0.3)&quot;)&#10;        &#10;        # Détailler les résultats par catégorie&#10;        if high_impact:&#10;            print(f&quot;\n LOIS À IMPACT TRÈS ÉLEVÉ:&quot;)&#10;            for i, result in enumerate(high_impact, 1):&#10;                reg = result['regulation']&#10;                print(f&quot;   {i}. {reg.get('nom_loi', '')}&quot;)&#10;                print(f&quot;       Score: {result['total_score']:.3f}&quot;)&#10;                print(f&quot;       Détail: Géo={result['score_details']['geo_score']:.2f} | &quot;&#10;                      f&quot;Secteur={result['score_details']['sector_score']:.2f} | &quot;&#10;                      f&quot;Keywords={result['score_details']['keyword_score']:.2f}&quot;)&#10;                print(f&quot;       Date effet: {reg.get('date_effet', 'N/A')}&quot;)&#10;                print(f&quot;       Sanctions: {reg.get('sanctions', 'Non spécifiées')}&quot;)&#10;                print()&#10;        &#10;        if medium_impact:&#10;            print(f&quot; LOIS À IMPACT MOYEN:&quot;)&#10;            for i, result in enumerate(medium_impact, 1):&#10;                reg = result['regulation']&#10;                print(f&quot;   {i}. {reg.get('nom_loi', '')}&quot;)&#10;                print(f&quot;       Score: {result['total_score']:.3f}&quot;)&#10;                print(f&quot;       Date effet: {reg.get('date_effet', 'N/A')}&quot;)&#10;                print()&#10;        &#10;        # Créer un rapport pour l'analyse LLM&#10;        if high_impact or medium_impact:&#10;            print(f&quot;\n GÉNÉRATION DE L'ANALYSE LLM...&quot;)&#10;            &#10;            # Préparer le rapport pour le LLM&#10;            llm_report = {&#10;                &quot;risk_summary&quot;: {&#10;                    &quot;high_risk_count&quot;: len(high_impact),&#10;                    &quot;medium_risk_count&quot;: len(medium_impact),&#10;                    &quot;low_risk_count&quot;: len(low_impact),&#10;                    &quot;average_risk_score&quot;: sum(r['total_score'] for r in matching_results) / len(matching_results)&#10;                },&#10;                &quot;detailed_analysis&quot;: {&#10;                    &quot;high_risk&quot;: [],&#10;                    &quot;medium_risk&quot;: []&#10;                }&#10;            }&#10;            &#10;            # Ajouter les détails des risques élevés&#10;            for result in high_impact:&#10;                reg = result['regulation']&#10;                llm_report[&quot;detailed_analysis&quot;][&quot;high_risk&quot;].append({&#10;                    &quot;regulation&quot;: {&#10;                        &quot;titre&quot;: reg.get('nom_loi', ''),&#10;                        &quot;texte&quot;: str(reg.get('texte', ''))[:500] + &quot;...&quot;,&#10;                        &quot;score&quot;: result['total_score']&#10;                    },&#10;                    &quot;impact_details&quot;: [&#10;                        f&quot;Score géographique: {result['score_details']['geo_score']:.2f}&quot;,&#10;                        f&quot;Score sectoriel: {result['score_details']['sector_score']:.2f}&quot;,&#10;                        f&quot;Date effet: {reg.get('date_effet', 'N/A')}&quot;,&#10;                        f&quot;Sanctions: {reg.get('sanctions', 'Non spécifiées')}&quot;&#10;                    ]&#10;                })&#10;            &#10;            # Profil Hutchinson pour le LLM&#10;            hutch_profile_llm = {&#10;                &quot;nom&quot;: hutchinson.get('company_info', {}).get('name', 'Hutchinson'),&#10;                &quot;secteur&quot;: ', '.join(hutchinson.get('company_info', {}).get('sectors', [])),&#10;                &quot;presence_geographique&quot;: hutchinson.get('geographical_presence', [])[:5],  # Limiter pour le prompt&#10;                &quot;matieres_premieres&quot;: hutchinson.get('typical_materials', [])[:5],&#10;                &quot;fournisseurs_regions&quot;: hutchinson.get('geographical_presence', [])[:3]&#10;            }&#10;            &#10;            # Générer l'analyse LLM&#10;            llm_analysis = rag_system.generate_llm_analysis(llm_report, hutch_profile_llm)&#10;            &#10;            print(&quot;✅ Analyse LLM générée&quot;)&#10;            print(f&quot; Taille: {len(llm_analysis)} caractères&quot;)&#10;            &#10;            # Afficher l'analyse LLM&#10;            print(f&quot;\n&quot; + &quot;=&quot;*60)&#10;            print(&quot; ANALYSE LLM AVEC DONNÉES RÉELLES:&quot;)&#10;            print(&quot;=&quot;*60)&#10;            print(llm_analysis)&#10;            print(&quot;=&quot;*60)&#10;            &#10;            # Sauvegarder le rapport avec données réelles&#10;            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')&#10;            filename = f&quot;hutchinson_real_data_analysis_{timestamp}.txt&quot;&#10;            &#10;            with open(filename, 'w', encoding='utf-8') as f:&#10;                f.write(&quot;ANALYSE DES RISQUES RÉGLEMENTAIRES - HUTCHINSON (DONNÉES RÉELLES)\n&quot;)&#10;                f.write(&quot;=&quot; * 70 + &quot;\n\n&quot;)&#10;                f.write(f&quot;Date: {datetime.now().strftime('%d/%m/%Y %H:%M')}\n&quot;)&#10;                f.write(f&quot;Nombre de réglementations analysées: {len(regulations)}\n\n&quot;)&#10;                &#10;                f.write(&quot;RÉSULTATS DU MATCHING:\n&quot;)&#10;                f.write(f&quot;• Lois à impact TRÈS ÉLEVÉ: {len(high_impact)}\n&quot;)&#10;                f.write(f&quot;• Lois à impact MOYEN: {len(medium_impact)}\n&quot;)&#10;                f.write(f&quot;• Lois à impact FAIBLE: {len(low_impact)}\n&quot;)&#10;                f.write(f&quot;• Lois négligeables: {len(negligible)}\n\n&quot;)&#10;                &#10;                if high_impact:&#10;                    f.write(&quot;DÉTAIL DES LOIS À IMPACT TRÈS ÉLEVÉ:\n&quot;)&#10;                    for i, result in enumerate(high_impact, 1):&#10;                        reg = result['regulation']&#10;                        f.write(f&quot;{i}. {reg.get('nom_loi', '')}\n&quot;)&#10;                        f.write(f&quot;   Score: {result['total_score']:.3f}\n&quot;)&#10;                        f.write(f&quot;   ID: {reg.get('id_loi', 'N/A')}\n&quot;)&#10;                        f.write(f&quot;   Type: {reg.get('type', 'N/A')}\n&quot;)&#10;                        f.write(f&quot;   Pays concernés: {reg.get('pays_concernes', 'N/A')}\n&quot;)&#10;                        f.write(f&quot;   Date effet: {reg.get('date_effet', 'N/A')}\n&quot;)&#10;                        f.write(f&quot;   Date vigueur: {reg.get('date_vigueur', 'N/A')}\n\n&quot;)&#10;                &#10;                f.write(&quot;\n&quot; + &quot;=&quot;*70 + &quot;\n&quot;)&#10;                f.write(&quot;ANALYSE LLM:\n&quot;)&#10;                f.write(&quot;=&quot;*70 + &quot;\n&quot;)&#10;                f.write(llm_analysis)&#10;            &#10;            print(f&quot;\n Rapport sauvegardé: {filename}&quot;)&#10;            &#10;        else:&#10;            print(f&quot;\n⚠️ Aucune loi à impact élevé ou moyen détectée&quot;)&#10;            print(f&quot;Les réglementations actuelles ont des scores d'impact faibles pour Hutchinson&quot;)&#10;        &#10;        # Résumé final&#10;        print(f&quot;\n TEST AVEC DONNÉES RÉELLES TERMINÉ !&quot;)&#10;        print(f&quot;\n RÉSUMÉ:&quot;)&#10;        print(f&quot;   • Réglementations analysées: {len(regulations)}&quot;)&#10;        print(f&quot;   • Lois critiques détectées: {len(high_impact)}&quot;)&#10;        print(f&quot;   • Lois à surveiller: {len(medium_impact)}&quot;)&#10;        print(f&quot;   • Score moyen d'impact: {sum(r['total_score'] for r in matching_results) / len(matching_results):.3f}&quot;)&#10;        &#10;        client.close()&#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Erreur: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;        return False&#10;&#10;def calculate_real_matching_score(regulation, hutchinson_profile):&#10;    &quot;&quot;&quot;Calcule le score de matching avec les données réelles&quot;&quot;&quot;&#10;    &#10;    score_details = {&#10;        'geo_score': 0.0,&#10;        'sector_score': 0.0,&#10;        'keyword_score': 0.0,&#10;        'total_score': 0.0&#10;    }&#10;    &#10;    # 1. Score géographique (30%)&#10;    hutch_geo = hutchinson_profile.get('geographical_presence', [])&#10;    reg_countries = regulation.get('pays_concernes', [])&#10;    &#10;    if hutch_geo and reg_countries:&#10;        # Convertir en sets pour intersection&#10;        hutch_geo_set = set([str(country).strip() for country in hutch_geo])&#10;        reg_countries_set = set([str(country).strip() for country in reg_countries])&#10;        &#10;        geo_matches = len(hutch_geo_set &amp; reg_countries_set)&#10;        if geo_matches &gt; 0:&#10;            score_details['geo_score'] = min(1.0, geo_matches / len(reg_countries_set)) * 0.3&#10;    &#10;    # 2. Score sectoriel (40%)&#10;    hutch_sectors = hutchinson_profile.get('company_info', {}).get('sectors', [])&#10;    reg_sectors = regulation.get('secteurs', [])&#10;    &#10;    if hutch_sectors and reg_sectors:&#10;        hutch_sectors_lower = [str(s).lower().strip() for s in hutch_sectors]&#10;        reg_sectors_lower = [str(s).lower().strip() for s in reg_sectors]&#10;        &#10;        sector_matches = len(set(hutch_sectors_lower) &amp; set(reg_sectors_lower))&#10;        if sector_matches &gt; 0:&#10;            score_details['sector_score'] = min(1.0, sector_matches / len(reg_sectors_lower)) * 0.4&#10;    &#10;    # 3. Score mots-clés (30%)&#10;    # Utiliser les mots-clés d'activité Hutchinson&#10;    hutch_keywords = []&#10;    if 'business_activities' in hutchinson_profile:&#10;        for activity_list in hutchinson_profile['business_activities'].values():&#10;            hutch_keywords.extend(activity_list)&#10;    &#10;    # Ajouter les matériaux&#10;    if 'typical_materials' in hutchinson_profile:&#10;        hutch_keywords.extend(hutchinson_profile['typical_materials'])&#10;    &#10;    reg_keywords = regulation.get('mots_cles', [])&#10;    &#10;    if hutch_keywords and reg_keywords:&#10;        hutch_keywords_clean = [str(k).lower().replace('_', ' ') for k in hutch_keywords]&#10;        reg_keywords_clean = [str(k).lower() for k in reg_keywords]&#10;        &#10;        keyword_matches = len(set(hutch_keywords_clean) &amp; set(reg_keywords_clean))&#10;        if keyword_matches &gt; 0:&#10;            score_details['keyword_score'] = min(1.0, keyword_matches / len(reg_keywords_clean)) * 0.3&#10;    &#10;    # 4. Score dans le texte (bonus)&#10;    reg_text = str(regulation.get('texte', '')).lower()&#10;    hutch_materials = hutchinson_profile.get('typical_materials', [])&#10;    &#10;    text_bonus = 0&#10;    for material in hutch_materials:&#10;        clean_material = str(material).replace('_', ' ').lower()&#10;        if clean_material in reg_text:&#10;            text_bonus += 0.02  # Petit bonus par matériau trouvé&#10;    &#10;    # Score total&#10;    score_details['total_score'] = min(1.0, &#10;        score_details['geo_score'] + &#10;        score_details['sector_score'] + &#10;        score_details['keyword_score'] + &#10;        text_bonus&#10;    )&#10;    &#10;    return score_details&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    print(&quot; TEST AVEC VOS DONNÉES RÉELLES&quot;)&#10;    print(&quot;Ce test va analyser les vraies réglementations dans votre base MongoDB&quot;)&#10;    print(&quot;\n&quot; + &quot;=&quot;*60)&#10;    &#10;    success = test_with_real_data()&#10;    &#10;    if success:&#10;        print(f&quot;\n SYSTÈME TESTÉ AVEC SUCCÈS SUR VOS DONNÉES RÉELLES !&quot;)&#10;        print(f&quot;Votre système peut analyser et matcher les vraies réglementations&quot;)&#10;        print(f&quot;stockées dans votre collection MongoDB.&quot;)&#10;    else:&#10;        print(f&quot;\n❌ Problème détecté avec les données réelles&quot;)&#10;        print(f&quot;Vérifiez que la base MongoDB contient des données&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>